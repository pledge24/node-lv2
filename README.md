### **1. 암호화 방식**

### **비밀번호를 DB에 저장할 때 Hash를 이용했는데, Hash는 단방향 암호화와 양방향 암호화 중 어떤 암호화 방식에 해당할까요?**

- Hash는 단방향 암호화 방식에 해당합니다. 한 번 Hash를 거치면 원래 값을 복원할 수 없기 때문에 단방향입니다.

### **비밀번호를 그냥 저장하지 않고 Hash 한 값을 저장 했을 때의 좋은 점은 무엇인가요?**

- **보안성 향상**: 비밀번호를 평문으로 저장하지 않음으로써 데이터베이스가 유출되더라도 비밀번호가 노출되지 않습니다.
- **데이터 무결성**: 사용자가 입력한 비밀번호와 저장된 Hash 값의 일치 여부를 비교함으로써 데이터 무결성을 유지할 수 있습니다.
- **비밀번호 보안 강화**: Hashing을 통해 비밀번호를 강화할 수 있으며, 추가로 salt를 사용하면 동일한 비밀번호에 대해 다른 Hash 값을 가지게 하여 Rainbow Table 공격을 방지할 수 있습니다.

### **2. 인증 방식**

### **JWT(Json Web Token)을 이용해 인증 기능을 했는데, 만약 Access Token이 노출되었을 경우 발생할 수 있는 문제점은 무엇일까요?**

- **권한 탈취**: 노출된 Access Token을 통해 공격자는 해당 사용자의 권한으로 시스템에 접근할 수 있습니다.
- **데이터 유출**: 공격자가 사용자의 데이터를 무단으로 열람, 수정, 삭제할 수 있습니다.
- **서비스 남용**: 공격자가 사용자의 권한으로 서비스에 악의적으로 접근하여 서비스 이용을 방해할 수 있습니다.

### **해당 문제점을 보완하기 위한 방법으로는 어떤 것이 있을까요?**

- **짧은 만료 시간 설정**: Access Token의 유효기간을 짧게 설정하여 노출되더라도 영향이 적도록 합니다.
- **Refresh Token 사용**: 짧은 만료 시간의 Access Token과 함께 장기적인 세션을 유지하기 위한 Refresh Token을 사용합니다. Refresh Token이 유출되면 모든 토큰을 무효화하고 재발급을 진행합니다.
- **토큰 블랙리스트**: 유출된 토큰을 서버에서 블랙리스트에 등록하여 해당 토큰을 무효화합니다.

### **3. 인증과 인가**

### **인증과 인가가 무엇인지 각각 설명해 주세요.**

- **인증(Authentication)**: 사용자가 자신이 누구인지를 증명하는 과정입니다. 일반적으로 사용자 이름과 비밀번호를 통해 이루어지며, 시스템은 이를 검증하여 사용자가 주장하는 신원이 맞는지 확인합니다.
- **인가(Authorization)**: 인증된 사용자가 특정 자원에 접근할 수 있는 권한을 부여하는 과정입니다. 예를 들어, 특정 사용자가 특정 기능이나 데이터를 사용할 수 있는지 여부를 결정합니다.

### **위 API 구현 명세에서 인증을 필요로 하는 API와 그렇지 않은 API의 차이가 뭐라고 생각하시나요?**

- **인증이 필요한 API**: 민감한 데이터를 조회하거나 수정하는 등의 작업을 수행하는 API는 인증이 필요합니다. 예를 들어, 사용자 정보 수정, 아이템 구매 등의 API는 인증된 사용자만 접근할 수 있어야 합니다.
- **인증이 필요 없는 API**: 공용 데이터 조회 등 누구나 접근할 수 있는 정보를 제공하는 API는 인증이 필요 없습니다. 예를 들어, 상품 목록 조회 등의 API는 인증 없이도 접근할 수 있습니다.

### **아이템 생성, 수정 API는 인증을 필요로 하지 않는다고 했지만 사실은 어느 API보다도 인증이 필요한 API입니다. 왜 그럴까요?**

- **데이터 무결성 유지**: 인증되지 않은 사용자가 아이템을 생성하거나 수정할 수 있다면 데이터 무결성이 깨질 수 있습니다.
- **권한 남용 방지**: 인증되지 않은 사용자가 임의로 아이템을 생성하거나 수정하면 게임 경제 및 시스템 운영에 큰 영향을 미칠 수 있습니다.

### **4. Http Status Code**

과제를 진행하면서 사용한 Http Status Code를 모두 나열하고, 각각이 의미하는 것과 어떤 상황에 사용했는지 작성해 주세요.

- **200 OK**: 요청이 성공적으로 처리되었음을 나타냅니다. 데이터 조회, 수정, 삭제 등 성공적으로 완료된 경우 사용합니다.
- **201 Created**: 요청이 성공적으로 처리되었으며, 새로운 자원이 생성되었음을 나타냅니다. 예를 들어, 새 아이템을 생성한 경우 사용합니다.
- **400 Bad Request**: 잘못된 요청임을 나타냅니다. 클라이언트가 보낸 요청이 서버에서 이해할 수 없거나 잘못된 경우 사용합니다.
- **401 Unauthorized**: 인증이 필요하거나 인증에 실패했음을 나타냅니다. 인증이 필요한 API에 대한 요청에서 인증 정보가 없거나 잘못된 경우 사용합니다.
- **403 Forbidden**: 서버가 요청을 이해했지만 권한이 없음을 나타냅니다. 사용자가 해당 자원에 접근할 권한이 없는 경우 사용합니다.
- **404 Not Found**: 요청한 자원을 찾을 수 없음을 나타냅니다. 요청한 리소스가 서버에 없는 경우 사용합니다.
- **409 Conflict**: 요청한 자원에 충돌이 발생했음을 나타냅니다. 요청한 리소스가 서버에 중복되는 리소스가 존재하는 경우 사용합니다.
- **500 Internal Server Error**: 서버 내부 오류를 나타냅니다. 서버에서 요청을 처리하는 중에 예상치 못한 오류가 발생한 경우 사용합니다.

### **5. 게임 경제**

### **현재는 간편한 구현을 위해 캐릭터 테이블에 money라는 게임 머니 컬럼만 추가하였습니다.**

### **이렇게 되었을 때 어떠한 단점이 있을 수 있을까요?**

- **데이터 무결성 문제**: 여러 개의 거래가 동시에 발생할 때 Race Condition이 발생할 수 있습니다.
- **확장성 부족**: 게임 경제가 복잡해질수록 단일 컬럼으로 관리하기 어려워집니다. 예를 들어, 다양한 통화 종류가 필요할 경우 대응하기 어렵습니다.
- **변경 내역 추적 불가**: 돈의 입출금 내역을 기록하지 않으면 거래 내역을 추적할 수 없습니다.

### **이렇게 하지 않고 다르게 구현할 수 있는 방법은 어떤 것이 있을까요?**

- **트랜잭션 테이블 사용**: 별도의 트랜잭션 테이블을 만들어 각 거래 내역을 기록하고, 잔액은 트랜잭션의 합으로 계산합니다.
- **통화 종류 구분**: 다양한 통화 종류를 지원하기 위해 통화별로 별도의 컬럼을 두거나, 통화 종류를 구분할 수 있는 구조를 설계합니다.
- **동시성 제어**: 트랜잭션과 Lock을 사용하여 동시에 발생하는 거래에 대해 동시성 문제를 해결합니다.

### **아이템 구입 시에 가격을 클라이언트에서 입력하게 하면 어떠한 문제점이 있을 수 있을까요?**

- **가격 조작**: 클라이언트가 임의로 가격을 조작하여 서버에 요청할 수 있습니다.
- **신뢰성 부족**: 클라이언트에서 입력한 가격을 신뢰할 수 없기 때문에 서버에서 별도로 검증해야 합니다.
- **보안 취약성**: 공격자가 가격을 낮추거나 0으로 설정하여 부당한 이익을 취할 수 있습니다.
